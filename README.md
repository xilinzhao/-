### 使用c++实现简单的基于B+tree的KV存储
相对于纯粹使用线性数据结构（如数组或链表）存储和查找数据，B+树通常具有更快的存储和查找时间。B+树的特点使得它在处理大量数据时表现出色。
它具有较低的深度和更好的数据局部性，这意味着每次访问磁盘或内存时需要的I/O操作较少。此外，B+树还支持范围查询和顺序访问，这对于许多应用程序是重要的。

![单线程测试结果](test/单线程.JPG)
![多线程测试结果](test/多线程.png)

根据测试结果，对程序的性能进行评估。

### 测试的意义

- **并发性能评估**：通过并发插入和查找操作，测试评估了B+树在处理并发请求时的性能。这对于数据库和文件系统等需要高效并发访问的应用来说非常重要。
- **实用性验证**：测试模拟了实际使用场景中可能出现的并发读写操作，验证了B+树实现的实用性和稳定性。
- **性能基准**：为B+树的进一步优化和调整提供了性能基准。通过比较不同优化策略或数据结构改进前后的性能数据，可以明确优化的效果。

### 程序的评价效果

- **并发插入性能**：在并发插入操作中，两个线程共计插入了100,000个键值对，耗时约为242,292微秒（约0.242秒）。这显示了B+树处理大量数据插入请求的能力
- **并发查找性能**：并发查找操作耗时约为106,471微秒（约0.106秒），相对于插入操作，查找性能更好。

### 性能改进建议

- **减少锁的粒度**：使用细粒度锁或读写锁（`std::shared_mutex`）可能提高并发性能，特别是对于读多写少的场景。
- **锁的策略优化**：在不同操作中采用不同的锁策略，例如对于只读操作使用共享锁，对于写操作使用独占锁。
- **优化B+树实现**：在B+树实现中引入并发控制机制，如乐观锁或版本控制，可能进一步提升性能。

### 结论

这次测试提供了B+树在并发环境下的性能快照，展示了其作为存储结构在处理大量数据和请求时的有效性。此外，测试还表明，对于进一步提高B+树的并发性能，有必要在其内部实现中采用更细粒度的同步机制。

